# -*- coding: utf-8 -*-
"""epinion_network.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eaWVkkHzI48NR8E5F75fy5ZP26Yic9Zj
"""


import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import re
from collections import Counter
import networkx as nx # version networkx=2.3
import seaborn as sns
from collections import Counter
from sklearn import preprocessing
import math
from statistics import mean
import random
import os

BASE_PATH = "./datasets"
OUTPUT_PATH= "./outputs"
# BASE_PATH = "/content/drive/MyDrive/cs579/CS579-Project2/datasets"
# BASE_PATH = "datasets"

EPINIONS_FILENAME = "soc-sign-epinions.txt"
ORIGIN_COLUMNS = ['FromNodeId', 'ToNodeId', 'Sign']

def print_ten_sample(d, msg="print out check: "):
  keylist = list(d.keys()) # edge list
  out = keylist[0: 10]
  # printing result
  print(msg)
  for key in out:
    print(f"{key} : {d[key]}")

# https://snap.stanford.edu/data/soc-sign-epinions.html
ep_data = os.path.join(BASE_PATH, EPINIONS_FILENAME)
df = pd.read_csv(ep_data,
                 skiprows=4,
                 nrows=5000,
                 delimiter='\t',
                 names=ORIGIN_COLUMNS)
# print("Number of entries: ", df.size)

print(df.head())

pd.set_option('display.expand_frame_repr', False)
pd.set_option('display.max_colwidth', 20)
print(df.shape)
print(df.head(5))

# pick out nodes and weights, stored in list and dictionary
graph_dict = {}


# seperate out product nodes and user node:
#p_nodes = list(set(df["FromNodeId"]))
#u_nodes = list(set(df["ToNodeId"]))
p_dict = {}
u_dict = {}


for index, row in df.iterrows():
    FromNodeId = row.get('FromNodeId')
    ToNodeId = row.get('ToNodeId')
    Sign = row.get('Sign')
    graph_dict[(FromNodeId, ToNodeId)] = {'Sign': Sign}

u_nodes, p_nodes = zip(*graph_dict.keys())
nodes = list(set(u_nodes + p_nodes))

print(f"Users[{len(df.FromNodeId.unique())}] , Products[{len(df.ToNodeId.unique())}], Nodes[{len(nodes)}]")

# add nodes to graph
G = nx.DiGraph()
G.add_nodes_from(nodes)

count = 0
for key in graph_dict.keys():
  if count % 100 == 0:
    G.add_edge(key[0], key[1])

nx.set_edge_attributes(G, graph_dict)
# nx.draw(G, pos=nx.circular_layout(G), node_color='r', edge_color='b')

#@title def plot_whole_graph(G): all nodes, not used...
def plot_whole_graph(G):
  plt.figure(figsize=(20,15))
  pos=nx.drawing.nx_pydot.pydot_layout(G, prog='fdp')
  #nx.draw(G, pos, node_color="#748AF9") # base color lightblue
  nx.draw(G,pos)
  labels = nx.get_edge_attributes(G,'weight')
  nx.draw_networkx_edge_labels(G,pos,edge_labels=labels)
  plt.draw()

#@title def plot_small_df(df): save to amazon_network_800n.png
def plot_small_df(df):
  small_df=df.drop(df.index[800:])

  # {(node1,node2):weight}
  small_nl = []
  edge_list = []

  for index, row in small_df.iterrows():
      n1 = row['FromNodeId']
      n2 = row['ToNodeId']
      edge = (n1,n2)
      edge_list.append(edge)

  # add nodes and edges to graph
  SG = nx.DiGraph()
  print(SG)
  SG.add_nodes_from(small_nl)
  SG.add_edges_from(edge_list)

  node_lb = {}
  for e in SG.edges:
    n1 = e[0]
    n2 = e[1]
    node_lb[n2] = SG.in_degree(n2)
    node_lb[n1] = SG.in_degree(n1)

  plt.figure(figsize=(20,10))

  pos=nx.drawing.nx_pydot.pydot_layout(SG, prog='fdp')
  #nx.draw(G, pos, node_color="#748AF9") # base color lightblue
  nx.draw(SG,pos)
  #nx.draw_networkx_edge_labels(G,pos,edge_labels=labels)
  nx.draw_networkx_labels(SG,pos,node_lb)
  plt.draw()
  plt.savefig(f'{OUTPUT_PATH}/epinion_network_800n.png')
  plt.show()

#@title def plot_hist(G): plot degree histogram

## Plot histogram
def plot_hist(G):
  plt.figure(figsize=(5, 5))
  deg_dict = Counter(nx.degree_histogram(G))

  y = []
  for key in deg_dict.keys():
    y.append(deg_dict[key])

  y = sorted(y,reverse=False)
  x = nx.degree_histogram(G)
  x = sorted(x,reverse=False)

  plt.hist(x, edgecolor="red", bins=y)
  plt.title("Degree Histogram")
  plt.ylabel("Count")
  plt.xlabel("Degree")
  plt.savefig(f'{OUTPUT_PATH}/epinion_network_histogram.png')
  plt.show()

#@title def plot_degree_dens(G): plot density of degree distribution
# https://seaborn.pydata.org/generated/seaborn.kdeplot.html
def plot_degree_dens(G):
  plt.figure(figsize=(8, 4))
  x = list(G.nodes)
  y = []
  for node in x:
    y.append(G.degree(node))

  # Make density plot
  sns.kdeplot(y)
  plt.xlim([0,1500])
  plt.savefig(f'{OUTPUT_PATH}/epinion_network_degree_density.png')
  plt.show()

#@title def get_astp(G): record average shortest path
#@markdown output: Nodes num: 55223, shortest path mean: 3.6516

# https://networkx.org/documentation/networkx-1.10/reference/generated/networkx.algorithms.shortest_paths.generic.average_shortest_path_length.html

def get_astp(G):
  #length = nx.average_shortest_path_length(G)
  for C in nx.connected_component_subgraphs(G):
      print(nx.average_shortest_path_length(C))
  #print(f"Average shortest path length is {length} ")

# plot a small network structure sneakpeak
plot_small_df(df)

# plot histogram
plot_hist(G)

"""
# realword network has:
# (1) power law distribution
# (2) high clustering coefficients
# (3) shorts average path length
"""
# show averate clustering coefficients
output_path=f'{OUTPUT_PATH}/epinion_ave_clustering.txt'
UG = G.to_undirected()
ave_clus = nx.average_clustering(G)

print(max(list(ave_clus.values())))
with open(output_path, encoding='utf-8', mode='w+') as f:
  f.write(f'Averate Clustering Coefficients: {ave_clus}')

# plot degree density
plot_degree_dens(G)

get_astp(G)

print("Averate Clustering Coefficients: ", ave_clus)
# 0.001766933069436154 is quite low!

# get average shortest path
# get_astp(G)
